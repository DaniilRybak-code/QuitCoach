import{df as c}from"./index-14a05817.js";class d{constructor(){this.isOnline=navigator.onLine,this.queue=new Map,this.failedQueue=new Map,this.syncInProgress=!1,this.retryDelays=[1e3,5e3,15e3,6e4],this.maxRetries=4,this.conflictResolution="server-wins",this.operationHandlers={CREATE:this.handleCreateOperation.bind(this),UPDATE:this.handleUpdateOperation.bind(this),DELETE:this.handleDeleteOperation.bind(this),BEHAVIORAL_LOG:this.handleBehavioralLogOperation.bind(this),FIRESTORE_ACTION:this.handleFirestoreActionOperation.bind(this)},this.initStorage(),this.setupNetworkListeners(),this.loadPersistedQueue(),console.log("🚀 OfflineQueueManager initialized")}initStorage(){this.dbName="QuitCoachOfflineQueue",this.dbVersion=2,this.initIndexedDB()}initIndexedDB(){return new Promise((e,t)=>{const s=indexedDB.open(this.dbName,this.dbVersion);s.onerror=()=>{console.error("❌ Failed to open IndexedDB for offline queue"),t(s.error)},s.onsuccess=i=>{this.db=i.target.result,console.log("✅ IndexedDB initialized for offline queue"),e(this.db)},s.onupgradeneeded=i=>{const n=i.target.result;if(!n.objectStoreNames.contains("operations")){const r=n.createObjectStore("operations",{keyPath:"id"});r.createIndex("timestamp","timestamp",{unique:!1}),r.createIndex("type","type",{unique:!1}),r.createIndex("status","status",{unique:!1}),r.createIndex("userId","userId",{unique:!1})}n.objectStoreNames.contains("conflicts")||n.createObjectStore("conflicts",{keyPath:"id"}).createIndex("operationId","operationId",{unique:!1}),n.objectStoreNames.contains("syncHistory")||n.createObjectStore("syncHistory",{keyPath:"id"}).createIndex("timestamp","timestamp",{unique:!1})}})}setupNetworkListeners(){window.addEventListener("online",()=>{console.log("🌐 Network connection restored"),this.isOnline=!0,this.handleReconnection()}),window.addEventListener("offline",()=>{console.log("📡 Network connection lost"),this.isOnline=!1,this.updateOfflineStatus()}),document.addEventListener("visibilitychange",()=>{!document.hidden&&this.isOnline&&this.attemptSync()}),setInterval(()=>{this.isOnline&&!this.syncInProgress&&this.attemptSync()},3e4)}async queueOperation(e){const t={id:this.generateOperationId(),type:e.type,data:e.data,userId:e.userId,timestamp:Date.now(),status:"queued",retryCount:0,maxRetries:this.maxRetries,priority:e.priority||"normal",dependencies:e.dependencies||[],metadata:e.metadata||{}};try{return await this.storeOperation(t),this.queue.set(t.id,t),console.log(`📝 Operation queued: ${e.type} (${t.id})`),this.showQueueNotification(t),this.isOnline&&this.attemptSync(),t.id}catch(s){throw console.error("❌ Error queuing operation:",s),s}}async storeOperation(e){if(!this.db)throw new Error("Database not initialized");return new Promise((t,s)=>{const r=this.db.transaction(["operations"],"readwrite").objectStore("operations").put(e);r.onsuccess=()=>t(r.result),r.onerror=()=>s(r.error)})}async loadPersistedQueue(){if(this.db)try{(await this.getAllOperations()).forEach(t=>{t.status==="queued"||t.status==="failed"?this.queue.set(t.id,t):t.status==="failed"&&this.failedQueue.set(t.id,t)}),console.log(`📱 Loaded ${this.queue.size} queued operations from storage`)}catch(e){console.error("❌ Error loading persisted queue:",e)}}async getAllOperations(){return this.db?new Promise((e,t)=>{const n=this.db.transaction(["operations"],"readonly").objectStore("operations").getAll();n.onsuccess=()=>e(n.result||[]),n.onerror=()=>t(n.error)}):[]}async attemptSync(){if(!(this.syncInProgress||!this.isOnline)){this.syncInProgress=!0,console.log("🔄 Starting sync attempt...");try{const e=await this.syncOperations();this.handleSyncResults(e)}catch(e){console.error("❌ Sync failed:",e),this.showSyncErrorNotification(e.message)}finally{this.syncInProgress=!1}}}handleSyncResults(e){var t;console.log("✅ Sync completed:",e),(t=this.progressManager)==null||t.updateProgress(100,"Sync completed"),this.showSyncSuccessNotification(e),this.clearCompletedOperations()}showSyncSuccessNotification(e){this.progressManager&&this.progressManager.showNotification("Sync completed successfully",`Synced ${e.successful} operations`,"success")}clearCompletedOperations(){this.queue=this.queue.filter(e=>e.status!=="completed"),this.saveQueue()}async syncOperations(){const e={successful:0,failed:0,conflicts:0,skipped:0},t=this.getOperationsByPriority();for(const s of["critical","high","normal","low"]){const i=t[s]||[];for(const n of i)try{const r=await this.executeOperation(n);r.success?(e.successful++,await this.removeOperation(n.id),this.queue.delete(n.id)):r.conflict?(e.conflicts++,await this.handleConflict(n,r.conflict)):(e.failed++,await this.handleOperationFailure(n,r.error))}catch(r){console.error(`❌ Error processing operation ${n.id}:`,r),e.failed++,await this.handleOperationFailure(n,r)}}return e}getOperationsByPriority(){return Array.from(this.queue.values()).reduce((t,s)=>(t[s.priority]||(t[s.priority]=[]),t[s.priority].push(s),t),{})}async executeOperation(e){const t=this.operationHandlers[e.type];if(!t)throw new Error(`No handler for operation type: ${e.type}`);if(!await this.checkDependencies(e))return{success:!1,skipped:!0};const i=await t(e);return e.status="completed",e.completedAt=Date.now(),await this.storeOperation(e),i}async checkDependencies(e){if(!e.dependencies||e.dependencies.length===0)return!0;for(const t of e.dependencies){const s=this.queue.get(t);if(s&&s.status!=="completed")return!1}return!0}async handleCreateOperation(e){try{const{collection:t,addDoc:s,serverTimestamp:i}=await c(()=>import("./index.esm-0076aa24.js"),["assets/index.esm-0076aa24.js","assets/index-14a05817.js","assets/index-9c597206.css"]),{firestore:n}=await c(()=>import("./index-14a05817.js").then(a=>a.dh),["assets/index-14a05817.js","assets/index-9c597206.css"]);return{success:!0,docId:(await s(t(n,e.data.collection),{...e.data.data,createdAt:i(),updatedAt:i()})).id}}catch(t){return console.error("❌ Create operation failed:",t),{success:!1,error:t}}}async handleUpdateOperation(e){try{const{doc:t,updateDoc:s,serverTimestamp:i}=await c(()=>import("./index.esm-0076aa24.js"),["assets/index.esm-0076aa24.js","assets/index-14a05817.js","assets/index-9c597206.css"]),{firestore:n}=await c(()=>import("./index-14a05817.js").then(a=>a.dh),["assets/index-14a05817.js","assets/index-9c597206.css"]),r=t(n,e.data.collection,e.data.docId);return await s(r,{...e.data.data,updatedAt:i()}),{success:!0}}catch(t){return console.error("❌ Update operation failed:",t),{success:!1,error:t}}}async handleDeleteOperation(e){try{const{doc:t,deleteDoc:s}=await c(()=>import("./index.esm-0076aa24.js"),["assets/index.esm-0076aa24.js","assets/index-14a05817.js","assets/index-9c597206.css"]),{firestore:i}=await c(()=>import("./index-14a05817.js").then(r=>r.dh),["assets/index-14a05817.js","assets/index-9c597206.css"]),n=t(i,e.data.collection,e.data.docId);return await s(n),{success:!0}}catch(t){return console.error("❌ Delete operation failed:",t),{success:!1,error:t}}}async handleBehavioralLogOperation(e){try{const{default:t}=await c(()=>import("./index-14a05817.js").then(n=>n.di),["assets/index-14a05817.js","assets/index-9c597206.css"]);return{success:!0,result:await new t().logBehavioralData(e.userId,e.data.logType,e.data.logData)}}catch(t){return console.error("❌ Behavioral log operation failed:",t),{success:!1,error:t}}}async handleFirestoreActionOperation(e){try{const{default:t}=await c(()=>import("./index-14a05817.js").then(n=>n.di),["assets/index-14a05817.js","assets/index-9c597206.css"]);return{success:!0,result:await new t().logBehavioralData(e.userId,e.data.actionType,e.data.actionData)}}catch(t){return console.error("❌ Firestore action operation failed:",t),{success:!1,error:t}}}async handleConflict(e,t){console.log(`⚠️ Conflict detected for operation ${e.id}:`,t);const s={id:this.generateOperationId(),operationId:e.id,conflictData:t,timestamp:Date.now(),resolution:null};await this.storeConflict(s);const i=await this.resolveConflict(e,t);i.resolved?(e.status="resolved",e.resolution=i,await this.storeOperation(e)):(e.status="conflict",await this.storeOperation(e))}async resolveConflict(e,t){switch(this.conflictResolution){case"server-wins":return{resolved:!0,strategy:"server-wins",data:t.serverData};case"client-wins":return{resolved:!0,strategy:"client-wins",data:e.data};case"merge":return await this.mergeConflictData(e.data,t);default:return{resolved:!1,strategy:"manual"}}}async mergeConflictData(e,t){return{resolved:!0,strategy:"merge",data:{...t.serverData,...e,clientUpdatedAt:e.updatedAt,serverUpdatedAt:t.serverData.updatedAt,mergedAt:Date.now()}}}async storeConflict(e){if(this.db)return new Promise((t,s)=>{const r=this.db.transaction(["conflicts"],"readwrite").objectStore("conflicts").put(e);r.onsuccess=()=>t(r.result),r.onerror=()=>s(r.error)})}async handleOperationFailure(e,t){if(e.retryCount++,e.lastError=t.message,e.lastRetryAt=Date.now(),e.retryCount>=e.maxRetries)e.status="failed",this.failedQueue.set(e.id,e),this.queue.delete(e.id),console.error(`❌ Operation ${e.id} failed permanently after ${e.maxRetries} retries`),this.showOperationFailedNotification(e);else{e.status="queued";const s=this.retryDelays[Math.min(e.retryCount-1,this.retryDelays.length-1)];console.log(`⏳ Operation ${e.id} will retry in ${s}ms (attempt ${e.retryCount}/${e.maxRetries})`),setTimeout(()=>{this.isOnline&&this.attemptSync()},s)}await this.storeOperation(e)}async removeOperation(e){if(this.db)return new Promise((t,s)=>{const r=this.db.transaction(["operations"],"readwrite").objectStore("operations").delete(e);r.onsuccess=()=>t(r.result),r.onerror=()=>s(r.error)})}async clearCompletedOperations(){if(this.db)try{const t=(await this.getAllOperations()).filter(s=>s.status==="completed");for(const s of t)await this.removeOperation(s.id);console.log(`🧹 Cleared ${t.length} completed operations`)}catch(e){console.error("❌ Error clearing completed operations:",e)}}showQueueNotification(e){const s={CREATE:"📝 Creating",UPDATE:"✏️ Updating",DELETE:"🗑️ Deleting",BEHAVIORAL_LOG:"📊 Logging",FIRESTORE_ACTION:"🔄 Syncing"}[e.type]||e.type;this.showNotification({type:"info",title:"💾 Saved Offline",message:`${s} will sync when you're back online`,duration:3e3})}showSyncResultsNotification(e){e.successful>0&&this.showNotification({type:"success",title:"✅ Sync Complete",message:`${e.successful} operation(s) synced successfully`,duration:5e3}),e.failed>0&&this.showNotification({type:"error",title:"⚠️ Sync Issues",message:`${e.failed} operation(s) failed to sync`,duration:8e3}),e.conflicts>0&&this.showNotification({type:"warning",title:"⚠️ Conflicts Detected",message:`${e.conflicts} operation(s) have conflicts that need attention`,duration:1e4})}showOperationFailedNotification(e){this.showNotification({type:"error",title:"❌ Operation Failed",message:`Operation ${e.type} failed permanently. Check your data.`,duration:1e4})}showSyncErrorNotification(e){this.showNotification({type:"error",title:"❌ Sync Error",message:`Sync failed: ${e}`,duration:8e3})}showNotification({type:e,title:t,message:s,duration:i=5e3}){const n=document.createElement("div");n.className=`fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 max-w-sm ${e==="success"?"bg-green-500":e==="error"?"bg-red-500":e==="warning"?"bg-yellow-500":"bg-blue-500"} text-white`,n.innerHTML=`
      <div class="font-bold">${t}</div>
      <div class="text-sm opacity-90 mt-1">${s}</div>
      <button class="mt-2 text-sm underline" onclick="this.parentElement.remove()">Dismiss</button>
    `,document.body.appendChild(n),setTimeout(()=>{n.parentNode&&n.parentNode.removeChild(n)},i)}generateOperationId(){return`op_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}async handleReconnection(){console.log("🔄 Handling reconnection..."),setTimeout(async()=>{await this.attemptSync()},2e3)}updateOfflineStatus(){const e=document.getElementById("offline-indicator");!e&&!this.isOnline?this.showOfflineIndicator():e&&this.isOnline&&this.hideOfflineIndicator()}showOfflineIndicator(){const e=document.createElement("div");e.id="offline-indicator",e.className="fixed top-4 left-1/2 transform -translate-x-1/2 bg-yellow-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 flex items-center gap-2",e.innerHTML=`
      <span>📡</span>
      <span>You're offline - ${this.queue.size} action(s) queued</span>
    `,document.body.appendChild(e)}hideOfflineIndicator(){const e=document.getElementById("offline-indicator");e&&e.remove()}async queueBehavioralLog(e,t,s,i="normal"){return await this.queueOperation({type:"BEHAVIORAL_LOG",userId:e,data:{logType:t,logData:s},priority:i})}async queueFirestoreAction(e,t,s,i="normal"){return await this.queueOperation({type:"FIRESTORE_ACTION",userId:e,data:{actionType:t,actionData:s},priority:i})}async queueCreate(e,t,s,i="normal"){return await this.queueOperation({type:"CREATE",userId:s,data:{collection:e,data:t},priority:i})}async queueUpdate(e,t,s,i,n="normal"){return await this.queueOperation({type:"UPDATE",userId:i,data:{collection:e,docId:t,data:s},priority:n})}async queueDelete(e,t,s,i="normal"){return await this.queueOperation({type:"DELETE",userId:s,data:{collection:e,docId:t},priority:i})}getQueueStatus(){return{isOnline:this.isOnline,queuedOperations:this.queue.size,failedOperations:this.failedQueue.size,syncInProgress:this.syncInProgress}}async getQueueDetails(){const e=Array.from(this.queue.values()),t=Array.from(this.failedQueue.values());return{queued:e.map(s=>({id:s.id,type:s.type,timestamp:s.timestamp,retryCount:s.retryCount,priority:s.priority})),failed:t.map(s=>({id:s.id,type:s.type,timestamp:s.timestamp,lastError:s.lastError}))}}async retryFailedOperations(){const e=Array.from(this.failedQueue.values());for(const t of e)t.status="queued",t.retryCount=0,t.lastError=null,this.queue.set(t.id,t),this.failedQueue.delete(t.id),await this.storeOperation(t);console.log(`🔄 Retrying ${e.length} failed operations`),this.isOnline&&this.attemptSync()}async clearAllQueues(){this.queue.clear(),this.failedQueue.clear(),this.db&&await this.db.transaction(["operations"],"readwrite").objectStore("operations").clear(),console.log("🧹 All queues cleared")}}class f{constructor(){this.resolutionStrategies={"server-wins":this.serverWinsStrategy.bind(this),"client-wins":this.clientWinsStrategy.bind(this),merge:this.mergeStrategy.bind(this),"timestamp-based":this.timestampBasedStrategy.bind(this),"field-based":this.fieldBasedStrategy.bind(this)}}detectConflict(e,t,s){const i=[];for(const n in e)t.hasOwnProperty(n)&&this.isFieldConflict(e[n],t[n],n)&&i.push({field:n,clientValue:e[n],serverValue:t[n],type:this.getConflictType(e[n],t[n],n)});return this.hasStructuralConflict(e,t)&&i.push({field:"structure",clientValue:e,serverValue:t,type:"structural"}),i.length>0?{hasConflict:!0,conflicts:i,operationType:s,timestamp:Date.now()}:null}isFieldConflict(e,t,s){return s.includes("timestamp")||s.includes("At")?!1:typeof e=="object"&&typeof t=="object"?JSON.stringify(e)!==JSON.stringify(t):e!==t}getConflictType(e,t,s){return s.includes("count")||s.includes("total")?"numeric":s.includes("date")||s.includes("time")?"temporal":typeof e=="boolean"&&typeof t=="boolean"?"boolean":Array.isArray(e)&&Array.isArray(t)?"array":"generic"}hasStructuralConflict(e,t){const s=Object.keys(e),i=Object.keys(t);return s.length!==i.length?!0:!s.every(n=>i.includes(n))}async resolveConflict(e,t="merge"){const s=this.resolutionStrategies[t];if(!s)throw new Error(`Unknown conflict resolution strategy: ${t}`);return await s(e)}serverWinsStrategy(e){return{resolved:!0,strategy:"server-wins",data:e.serverValue,reason:"Server data takes precedence"}}clientWinsStrategy(e){return{resolved:!0,strategy:"client-wins",data:e.clientValue,reason:"Client data takes precedence"}}mergeStrategy(e){if(e.conflicts.length===0)return{resolved:!0,strategy:"merge",data:{...e.serverValue,...e.clientValue},reason:"No field conflicts detected"};const t={...e.serverValue};for(const s of e.conflicts){const i=this.resolveFieldConflict(s);t[s.field]=i.value}return{resolved:!0,strategy:"merge",data:t,reason:"Fields merged using intelligent resolution",fieldResolutions:e.conflicts.map(s=>({field:s.field,resolution:this.resolveFieldConflict(s)}))}}timestampBasedStrategy(e){const t=this.extractTimestamp(e.clientValue),s=this.extractTimestamp(e.serverValue);return t>s?this.clientWinsStrategy(e):this.serverWinsStrategy(e)}fieldBasedStrategy(e){const t={};let s=!1;for(const n of e.conflicts){const r=this.resolveFieldConflict(n);t[n.field]=r,r.resolved||(s=!0)}if(s)return{resolved:!1,strategy:"field-based",reason:"Some fields require manual resolution",fieldResolutions:t};const i={...e.serverValue};for(const[n,r]of Object.entries(t))i[n]=r.value;return{resolved:!0,strategy:"field-based",data:i,reason:"All fields resolved automatically",fieldResolutions:t}}resolveFieldConflict(e){const{field:t,clientValue:s,serverValue:i,type:n}=e;switch(n){case"numeric":return this.resolveNumericConflict(t,s,i);case"temporal":return this.resolveTemporalConflict(t,s,i);case"boolean":return this.resolveBooleanConflict(t,s,i);case"array":return this.resolveArrayConflict(t,s,i);case"generic":return this.resolveGenericConflict(t,s,i);default:return{resolved:!1,value:i,reason:"Unknown conflict type"}}}resolveNumericConflict(e,t,s){const i=Math.max(t,s);return{resolved:!0,value:i,reason:`Used maximum value for numeric field: ${i}`}}resolveTemporalConflict(e,t,s){const i=new Date(t).getTime(),n=new Date(s).getTime(),r=Math.max(i,n);return{resolved:!0,value:new Date(r).toISOString(),reason:"Used latest timestamp for temporal field"}}resolveBooleanConflict(e,t,s){const i=t||s;return{resolved:!0,value:i,reason:`Used OR logic for boolean field: ${i}`}}resolveArrayConflict(e,t,s){const i=[...new Set([...t,...s])];return{resolved:!0,value:i,reason:`Merged arrays and removed duplicates: ${i.length} items`}}resolveGenericConflict(e,t,s){return{resolved:!0,value:t,reason:"Used client value for generic field",metadata:{serverValue:s,conflictResolvedAt:Date.now()}}}extractTimestamp(e){if(typeof e=="string"){const t=new Date(e);return isNaN(t.getTime())?0:t.getTime()}if(typeof e=="number")return e;if(e&&typeof e=="object"){const t=["timestamp","createdAt","updatedAt","lastModified"];for(const s of t)if(e[s]){const i=new Date(e[s]);if(!isNaN(i.getTime()))return i.getTime()}}return 0}analyzeConflict(e){const t={severity:"low",complexity:"simple",recommendations:[],autoResolvable:!0},s=e.conflicts.map(i=>i.type);return s.includes("structural")?(t.severity="high",t.autoResolvable=!1,t.recommendations.push("Manual review required for structural conflicts")):s.includes("temporal")&&(t.severity="medium",t.recommendations.push("Consider timestamp-based resolution")),e.conflicts.length>5?t.complexity="complex":e.conflicts.length>2&&(t.complexity="moderate"),s.includes("numeric")&&t.recommendations.push("Consider using maximum value for numeric fields"),s.includes("array")&&t.recommendations.push("Merge arrays and remove duplicates"),t}async logConflict(e,t){const s={id:`conflict_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,conflict:e,resolution:t,timestamp:Date.now(),analysis:this.analyzeConflict(e)};try{const{openDB:i}=await c(()=>import("./index-14a05817.js").then(r=>r.dg),["assets/index-14a05817.js","assets/index-9c597206.css"]);await(await i("QuitCoachConflicts",1,{upgrade(r){r.objectStoreNames.contains("conflicts")||r.createObjectStore("conflicts",{keyPath:"id"})}})).put("conflicts",s)}catch(i){console.warn("Could not log conflict:",i)}return s}async getConflictHistory(e=100){try{const{openDB:t}=await c(()=>import("./index-14a05817.js").then(a=>a.dg),["assets/index-14a05817.js","assets/index-9c597206.css"]);return(await(await t("QuitCoachConflicts",1)).transaction("conflicts","readonly").objectStore("conflicts").getAll()).sort((a,o)=>o.timestamp-a.timestamp).slice(0,e)}catch(t){return console.warn("Could not retrieve conflict history:",t),[]}}async getConflictStatistics(){const e=await this.getConflictHistory(1e3),t={totalConflicts:e.length,resolvedConflicts:e.filter(i=>i.resolution.resolved).length,unresolvedConflicts:e.filter(i=>!i.resolution.resolved).length,conflictTypes:{},resolutionStrategies:{},averageResolutionTime:0};e.forEach(i=>{i.conflict.conflicts.forEach(r=>{const a=r.type;t.conflictTypes[a]=(t.conflictTypes[a]||0)+1});const n=i.resolution.strategy;t.resolutionStrategies[n]=(t.resolutionStrategies[n]||0)+1});const s=e.filter(i=>i.resolution.resolved);if(s.length>0){const i=s.reduce((n,r)=>n+(r.timestamp-r.conflict.timestamp),0);t.averageResolutionTime=i/s.length}return t}}class h{constructor(){this.syncSessions=new Map,this.currentSession=null,this.progressCallbacks=new Set,this.statusCallbacks=new Set,this.STATUS={IDLE:"idle",CONNECTING:"connecting",SYNCING:"syncing",COMPLETED:"completed",FAILED:"failed",PAUSED:"paused"},this.PROGRESS_UPDATE_INTERVAL=100,this.STATUS_UPDATE_INTERVAL=1e3,this.init()}init(){this.progressInterval=setInterval(()=>{this.updateProgress()},this.PROGRESS_UPDATE_INTERVAL),this.statusInterval=setInterval(()=>{this.updateStatus()},this.STATUS_UPDATE_INTERVAL)}startSyncSession(e,t="manual"){const s=this.generateSessionId(),i={id:s,type:t,startTime:Date.now(),endTime:null,status:this.STATUS.CONNECTING,totalOperations:e,completedOperations:0,failedOperations:0,conflictedOperations:0,skippedOperations:0,currentOperation:null,progress:0,estimatedTimeRemaining:null,operations:[],errors:[],conflicts:[]};return this.syncSessions.set(s,i),this.currentSession=i,console.log(`🔄 Started sync session ${s} with ${e} operations`),this.notifyStatusChange(i),s}updateSyncProgress(e,t){const s=this.syncSessions.get(e);if(s){if(Object.assign(s,t),s.totalOperations>0&&(s.progress=Math.round(s.completedOperations/s.totalOperations*100)),s.completedOperations>0){const n=(Date.now()-s.startTime)/s.completedOperations,r=s.totalOperations-s.completedOperations;s.estimatedTimeRemaining=Math.round(n*r)}this.notifyProgressChange(s)}}completeSyncSession(e,t){const s=this.syncSessions.get(e);s&&(s.endTime=Date.now(),s.status=t.success?this.STATUS.COMPLETED:this.STATUS.FAILED,s.progress=100,s.estimatedTimeRemaining=0,Object.assign(s,t),console.log(`✅ Completed sync session ${e}:`,t),this.notifyStatusChange(s),this.showSyncResults(s),setTimeout(()=>{this.cleanupOldSessions()},3e4))}failSyncSession(e,t){const s=this.syncSessions.get(e);s&&(s.endTime=Date.now(),s.status=this.STATUS.FAILED,s.errors.push({message:t.message,timestamp:Date.now(),operation:s.currentOperation}),console.error(`❌ Failed sync session ${e}:`,t),this.notifyStatusChange(s),this.showSyncError(s,t))}startOperation(e,t){const s=this.syncSessions.get(e);s&&(s.currentOperation={id:t.id,type:t.type,startTime:Date.now(),status:"processing"},this.notifyStatusChange(s))}completeOperation(e,t,s){const i=this.syncSessions.get(e);i&&(i.currentOperation&&i.currentOperation.id===t&&(i.currentOperation.endTime=Date.now(),i.currentOperation.status="completed",i.currentOperation.result=s,i.completedOperations++,i.operations.push(i.currentOperation)),this.updateSyncProgress(e,{}))}failOperation(e,t,s){const i=this.syncSessions.get(e);i&&(i.currentOperation&&i.currentOperation.id===t&&(i.currentOperation.endTime=Date.now(),i.currentOperation.status="failed",i.currentOperation.error=s,i.failedOperations++,i.operations.push(i.currentOperation),i.errors.push({message:s.message,timestamp:Date.now(),operation:i.currentOperation})),this.updateSyncProgress(e,{}))}conflictOperation(e,t,s){const i=this.syncSessions.get(e);i&&(i.currentOperation&&i.currentOperation.id===t&&(i.currentOperation.endTime=Date.now(),i.currentOperation.status="conflicted",i.currentOperation.conflict=s,i.conflictedOperations++,i.operations.push(i.currentOperation),i.conflicts.push({operationId:t,conflict:s,timestamp:Date.now()})),this.updateSyncProgress(e,{}))}addProgressCallback(e){this.progressCallbacks.add(e)}removeProgressCallback(e){this.progressCallbacks.delete(e)}addStatusCallback(e){this.statusCallbacks.add(e)}removeStatusCallback(e){this.statusCallbacks.delete(e)}notifyProgressChange(e){this.progressCallbacks.forEach(t=>{try{t({sessionId:e.id,progress:e.progress,completed:e.completedOperations,total:e.totalOperations,estimatedTimeRemaining:e.estimatedTimeRemaining,currentOperation:e.currentOperation})}catch(s){console.error("Error in progress callback:",s)}})}notifyStatusChange(e){this.statusCallbacks.forEach(t=>{try{t({sessionId:e.id,status:e.status,startTime:e.startTime,endTime:e.endTime,totalOperations:e.totalOperations,completedOperations:e.completedOperations,failedOperations:e.failedOperations,conflictedOperations:e.conflictedOperations})}catch(s){console.error("Error in status callback:",s)}})}showSyncResults(e){const t=e.endTime-e.startTime,s=e.totalOperations>0?Math.round(e.completedOperations/e.totalOperations*100):0;let i="success",n="✅ Sync Complete",r=`${e.completedOperations} of ${e.totalOperations} operations synced successfully`;e.failedOperations>0&&(i="warning",n="⚠️ Sync Complete with Issues",r+=` (${e.failedOperations} failed)`),e.conflictedOperations>0&&(r+=` (${e.conflictedOperations} conflicts)`),this.showNotification({type:i,title:n,message:r,duration:8e3,details:{duration:this.formatDuration(t),successRate:`${s}%`,operations:{completed:e.completedOperations,failed:e.failedOperations,conflicted:e.conflictedOperations,total:e.totalOperations}}})}showSyncError(e,t){this.showNotification({type:"error",title:"❌ Sync Failed",message:`Sync failed: ${t.message}`,duration:1e4,details:{sessionId:e.id,error:t.message,operations:{completed:e.completedOperations,failed:e.failedOperations,total:e.totalOperations}}})}showSyncProgress(e){if(e.status!==this.STATUS.SYNCING)return;const t=e.progress||0,s=e.currentOperation,i=e.estimatedTimeRemaining;let n=`Syncing... ${t}%`;s&&(n+=` (${s.type})`),i&&(n+=` - ${this.formatDuration(i)} remaining`),this.showNotification({type:"info",title:"🔄 Syncing Data",message:n,duration:0,progress:t,showProgress:!0})}showNotification({type:e,title:t,message:s,duration:i=5e3,details:n=null,progress:r=null,showProgress:a=!1}){const o=document.createElement("div");o.className=`fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 max-w-sm ${e==="success"?"bg-green-500":e==="error"?"bg-red-500":e==="warning"?"bg-yellow-500":"bg-blue-500"} text-white`;let u=`
      <div class="font-bold">${t}</div>
      <div class="text-sm opacity-90 mt-1">${s}</div>
    `;return a&&r!==null&&(u+=`
        <div class="mt-2 bg-white bg-opacity-20 rounded-full h-2">
          <div class="bg-white h-2 rounded-full transition-all duration-300" style="width: ${r}%"></div>
        </div>
      `),n&&(u+=`
        <div class="mt-2 text-xs opacity-75">
          ${n.duration?`Duration: ${n.duration}`:""}
          ${n.successRate?` | Success: ${n.successRate}`:""}
        </div>
      `),u+=`
      <button class="mt-2 text-sm underline" onclick="this.parentElement.remove()">Dismiss</button>
    `,o.innerHTML=u,o.id=`sync-notification-${Date.now()}`,document.body.appendChild(o),i>0&&setTimeout(()=>{o.parentNode&&o.parentNode.removeChild(o)},i),o}updateProgress(){!this.currentSession||this.currentSession.status!==this.STATUS.SYNCING||this.showSyncProgress(this.currentSession)}updateStatus(){this.syncSessions.forEach(e=>{e.status===this.STATUS.SYNCING&&this.notifyStatusChange(e)})}generateSessionId(){return`sync_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}formatDuration(e){const t=Math.floor(e/1e3),s=Math.floor(t/60),i=Math.floor(s/60);return i>0?`${i}h ${s%60}m`:s>0?`${s}m ${t%60}s`:`${t}s`}cleanupOldSessions(){const e=Date.now()-864e5;this.syncSessions.forEach((t,s)=>{t.endTime&&t.endTime<e&&this.syncSessions.delete(s)})}getCurrentSession(){return this.currentSession}getSession(e){return this.syncSessions.get(e)}getAllSessions(){return Array.from(this.syncSessions.values())}getSyncStatistics(){const e=this.getAllSessions(),t=e.filter(a=>a.status===this.STATUS.COMPLETED),s=e.filter(a=>a.status===this.STATUS.FAILED),i=e.reduce((a,o)=>a+o.totalOperations,0),n=e.reduce((a,o)=>a+o.completedOperations,0),r=e.reduce((a,o)=>a+o.failedOperations,0);return{totalSessions:e.length,completedSessions:t.length,failedSessions:s.length,totalOperations:i,completedOperations:n,failedOperations:r,successRate:i>0?Math.round(n/i*100):0,averageSessionDuration:t.length>0?t.reduce((a,o)=>a+(o.endTime-o.startTime),0)/t.length:0}}destroy(){this.progressInterval&&clearInterval(this.progressInterval),this.statusInterval&&clearInterval(this.statusInterval),this.progressCallbacks.clear(),this.statusCallbacks.clear(),this.syncSessions.clear()}}class p{constructor(){this.isOnline=navigator.onLine,this.isInitialized=!1,this.queueManager=new d,this.conflictResolver=new f,this.progressManager=new h,this.offlineData={userData:null,profileData:null,cachedStats:null,lastSyncTime:null},this.syncConfig={autoSync:!0,syncInterval:3e4,maxRetries:3,conflictResolution:"merge",batchSize:10},this.init()}async init(){try{this.setupNetworkListeners(),this.setupProgressCallbacks(),await this.loadOfflineData(),this.syncConfig.autoSync&&this.startAutoSync(),this.isInitialized=!0,console.log("🚀 Enhanced Offline Manager initialized")}catch(e){console.error("❌ Failed to initialize Enhanced Offline Manager:",e)}}setupNetworkListeners(){window.addEventListener("online",()=>{console.log("🌐 Network connection restored"),this.isOnline=!0,this.handleReconnection()}),window.addEventListener("offline",()=>{console.log("📡 Network connection lost"),this.isOnline=!1,this.updateOfflineStatus()}),document.addEventListener("visibilitychange",()=>{!document.hidden&&this.isOnline&&this.attemptSync()})}setupProgressCallbacks(){this.progressManager.addProgressCallback(e=>{this.updateProgressUI(e)}),this.progressManager.addStatusCallback(e=>{this.updateStatusUI(e)})}async loadOfflineData(){try{this.offlineData.userData=JSON.parse(localStorage.getItem("offline_userData")||"null"),this.offlineData.profileData=JSON.parse(localStorage.getItem("offline_profileData")||"null"),this.offlineData.cachedStats=JSON.parse(localStorage.getItem("offline_cachedStats")||"null"),this.offlineData.lastSyncTime=JSON.parse(localStorage.getItem("offline_lastSyncTime")||"null"),console.log("📱 Offline data loaded:",{userData:!!this.offlineData.userData,profileData:!!this.offlineData.profileData,cachedStats:!!this.offlineData.cachedStats,lastSyncTime:this.offlineData.lastSyncTime})}catch(e){console.error("❌ Error loading offline data:",e)}}async cacheUserData(e){if(!e)return;const t={profile:{uid:e.uid,heroName:e.heroName,archetype:e.archetype,avatar:e.avatar,quitDate:e.quitDate,onboardingCompleted:e.onboardingCompleted},stats:e.stats||{},lastUpdated:Date.now()};await this.queueManager.storeData("userData",t),this.offlineData.userData=t}async cacheProfileData(e){if(!e)return;const t={dailyWater:e.dailyWater||0,dailyMood:e.dailyMood||null,dailyBreathing:e.dailyBreathing||!1,scheduledTriggers:e.scheduledTriggers||[],relapseDate:e.relapseDate||null,cravingsResisted:e.cravingsResisted||0,lastUpdated:Date.now()};await this.queueManager.storeData("profileData",t),this.offlineData.profileData=t}async cacheStats(e){if(!e)return;const t={streakDays:e.streakDays||0,cravingsResisted:e.cravingsResisted||0,addictionLevel:e.addictionLevel||50,mentalStrength:e.mentalStrength||50,lastUpdated:Date.now()};await this.queueManager.storeData("cachedStats",t),this.offlineData.cachedStats=t}async queueBehavioralLog(e,t,s,i="normal"){try{const n=await this.queueManager.queueBehavioralLog(e,t,s,i);return console.log(`📝 Behavioral log queued: ${t} (${n})`),n}catch(n){throw console.error("❌ Error queuing behavioral log:",n),n}}async queueFirestoreAction(e,t,s,i="normal"){try{const n=await this.queueManager.queueFirestoreAction(e,t,s,i);return console.log(`📝 Firestore action queued: ${t} (${n})`),n}catch(n){throw console.error("❌ Error queuing Firestore action:",n),n}}async queueCreate(e,t,s,i="normal"){try{const n=await this.queueManager.queueCreate(e,t,s,i);return console.log(`📝 Create operation queued: ${e} (${n})`),n}catch(n){throw console.error("❌ Error queuing create operation:",n),n}}async queueUpdate(e,t,s,i,n="normal"){try{const r=await this.queueManager.queueUpdate(e,t,s,i,n);return console.log(`📝 Update operation queued: ${e}/${t} (${r})`),r}catch(r){throw console.error("❌ Error queuing update operation:",r),r}}async queueDelete(e,t,s,i="normal"){try{const n=await this.queueManager.queueDelete(e,t,s,i);return console.log(`📝 Delete operation queued: ${e}/${t} (${n})`),n}catch(n){throw console.error("❌ Error queuing delete operation:",n),n}}async attemptSync(){if(!(!this.isOnline||!this.isInitialized))try{const e=this.queueManager.getQueueStatus();if(e.queuedOperations===0){console.log("✅ No operations to sync");return}console.log(`🔄 Starting sync with ${e.queuedOperations} operations`);const t=this.progressManager.startSyncSession(e.queuedOperations,"auto"),s=await this.performSyncWithProgress(t);this.progressManager.completeSyncSession(t,s),this.offlineData.lastSyncTime=Date.now(),await this.queueManager.storeData("lastSyncTime",this.offlineData.lastSyncTime)}catch(e){console.error("❌ Sync failed:",e),this.progressManager.failSyncSession(sessionId,e)}}async performSyncWithProgress(e){const t={successful:0,failed:0,conflicts:0,skipped:0};try{const i=(await this.queueManager.getQueueDetails()).queued,n=this.createBatches(i,this.syncConfig.batchSize);for(const r of n){const a=await this.processBatch(e,r);t.successful+=a.successful,t.failed+=a.failed,t.conflicts+=a.conflicts,t.skipped+=a.skipped}return t}catch(s){throw console.error("❌ Error in sync progress:",s),s}}createBatches(e,t){const s=[];for(let i=0;i<e.length;i+=t)s.push(e.slice(i,i+t));return s}async processBatch(e,t){const s={successful:0,failed:0,conflicts:0,skipped:0};for(const i of t)try{this.progressManager.startOperation(e,i);const n=await this.executeOperation(i);n.success?(s.successful++,this.progressManager.completeOperation(e,i.id,n)):n.conflict?(s.conflicts++,this.progressManager.conflictOperation(e,i.id,n.conflict)):(s.failed++,this.progressManager.failOperation(e,i.id,n.error))}catch(n){s.failed++,this.progressManager.failOperation(e,i.id,n)}return s}async executeOperation(e){try{const t=await this.queueManager.executeOperation(e);if(t.success)return{success:!0,result:t};if(t.conflict){const s=await this.conflictResolver.resolveConflict(t.conflict,this.syncConfig.conflictResolution);if(s.resolved){e.data=s.data;const i=await this.queueManager.executeOperation(e);return{success:i.success,result:i}}else return{success:!1,conflict:t.conflict}}else return{success:!1,error:t.error}}catch(t){return{success:!1,error:t}}}startAutoSync(){this.autoSyncInterval&&clearInterval(this.autoSyncInterval),this.autoSyncInterval=setInterval(()=>{this.isOnline&&this.attemptSync()},this.syncConfig.syncInterval)}stopAutoSync(){this.autoSyncInterval&&(clearInterval(this.autoSyncInterval),this.autoSyncInterval=null)}async handleReconnection(){console.log("🔄 Handling reconnection..."),setTimeout(async()=>{await this.attemptSync()},2e3)}updateOfflineStatus(){const e=document.getElementById("offline-indicator");!e&&!this.isOnline?this.showOfflineIndicator():e&&this.isOnline&&this.hideOfflineIndicator()}showOfflineIndicator(){const e=document.createElement("div");e.id="offline-indicator",e.className="fixed top-4 left-1/2 transform -translate-x-1/2 bg-yellow-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 flex items-center gap-2";const t=this.queueManager.getQueueStatus();e.innerHTML=`
      <span>📡</span>
      <span>You're offline - ${t.queuedOperations} action(s) queued</span>
    `,document.body.appendChild(e)}hideOfflineIndicator(){const e=document.getElementById("offline-indicator");e&&e.remove()}updateProgressUI(e){document.querySelectorAll(".sync-progress").forEach(s=>{s.style.width=`${e.progress}%`,s.textContent=`${e.progress}%`})}updateStatusUI(e){document.querySelectorAll(".sync-status").forEach(s=>{s.textContent=e.status,s.className=`sync-status ${e.status}`})}updateSyncConfig(e){this.syncConfig={...this.syncConfig,...e},e.syncInterval&&(this.stopAutoSync(),this.syncConfig.autoSync&&this.startAutoSync())}getStatus(){const e=this.queueManager.getQueueStatus(),t=this.progressManager.getSyncStatistics();return{isOnline:this.isOnline,isInitialized:this.isInitialized,queue:e,sync:t,config:this.syncConfig}}async getQueueDetails(){return await this.queueManager.getQueueDetails()}async retryFailedOperations(){await this.queueManager.retryFailedOperations(),this.isOnline&&await this.attemptSync()}async clearAllQueues(){await this.queueManager.clearAllQueues()}async getConflictHistory(){return await this.conflictResolver.getConflictHistory()}async getConflictStatistics(){return await this.conflictResolver.getConflictStatistics()}destroy(){this.stopAutoSync(),this.progressManager.destroy(),this.queueManager=null,this.conflictResolver=null,this.progressManager=null}}class y{constructor(){this.isOnline=navigator.onLine,this.syncQueue=[],this.offlineData={},this.lastSyncTime=null,this.enhancedManager=new p,this.initOfflineStorage(),this.setupNetworkListeners(),this.loadOfflineData()}initOfflineStorage(){window.indexedDB?(this.storageType="indexedDB",this.initIndexedDB()):(this.storageType="localStorage",console.log("IndexedDB not available, using localStorage for offline storage"))}initIndexedDB(){const e=indexedDB.open("QuitCoachOffline",1);e.onerror=()=>{console.warn("IndexedDB failed, falling back to localStorage"),this.storageType="localStorage"},e.onsuccess=t=>{this.db=t.target.result,console.log("IndexedDB initialized for offline storage")},e.onupgradeneeded=t=>{const s=t.target.result;s.objectStoreNames.contains("userData")||s.createObjectStore("userData",{keyPath:"id"}),s.objectStoreNames.contains("offlineActions")||s.createObjectStore("offlineActions",{keyPath:"timestamp"}),s.objectStoreNames.contains("syncQueue")||s.createObjectStore("syncQueue",{keyPath:"id"})}}setupNetworkListeners(){window.addEventListener("online",()=>{console.log("🌐 Network connection restored"),this.isOnline=!0,this.handleReconnection()}),window.addEventListener("offline",()=>{console.log("📡 Network connection lost"),this.isOnline=!1,this.updateOfflineStatus()}),document.addEventListener("visibilitychange",()=>{!document.hidden&&this.isOnline&&this.checkForPendingSync()})}async storeData(e,t){try{this.storageType==="indexedDB"&&this.db?await this.db.transaction(["userData"],"readwrite").objectStore("userData").put({id:e,data:t,timestamp:Date.now()}):localStorage.setItem(`offline_${e}`,JSON.stringify({data:t,timestamp:Date.now()})),console.log(`✅ Data stored offline: ${e}`)}catch(s){console.error("Error storing offline data:",s)}}async getData(e){try{if(this.storageType==="indexedDB"&&this.db){const i=this.db.transaction(["userData"],"readonly").objectStore("userData").get(e);return new Promise((n,r)=>{i.onsuccess=()=>{var a;n(((a=i.result)==null?void 0:a.data)||null)},i.onerror=()=>r(i.error)})}else{const t=localStorage.getItem(`offline_${e}`);return t?JSON.parse(t).data:null}}catch(t){return console.error("Error retrieving offline data:",t),null}}async removeData(e){try{this.storageType==="indexedDB"&&this.db?await this.db.transaction(["userData"],"readwrite").objectStore("userData").delete(e):localStorage.removeItem(`offline_${e}`)}catch(t){console.error("Error removing offline data:",t)}}async queueOfflineAction(e){const t={id:`action_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,action:e,timestamp:Date.now(),retryCount:0,maxRetries:3};try{if(this.storageType==="indexedDB"&&this.db)await this.db.transaction(["syncQueue"],"readwrite").objectStore("syncQueue").add(t);else{const s=JSON.parse(localStorage.getItem("offline_syncQueue")||"[]");s.push(t),localStorage.setItem("offline_syncQueue",JSON.stringify(s))}return this.syncQueue.push(t),console.log(`📝 Action queued for sync: ${e.type}`),this.showOfflineIndicator(),t.id}catch(s){return console.error("Error queuing offline action:",s),null}}async getQueuedActions(){try{if(this.storageType==="indexedDB"&&this.db){const s=this.db.transaction(["syncQueue"],"readonly").objectStore("syncQueue").getAll();return new Promise((i,n)=>{s.onsuccess=()=>{i(s.result||[])},s.onerror=()=>n(s.error)})}else return JSON.parse(localStorage.getItem("offline_syncQueue")||"[]")}catch(e){return console.error("Error getting queued actions:",e),[]}}async getQueuedActionsCount(){try{return(await this.getQueuedActions()).length}catch(e){return console.error("Error getting queued actions count:",e),0}}async removeQueuedAction(e){try{if(this.storageType==="indexedDB"&&this.db)await this.db.transaction(["syncQueue"],"readwrite").objectStore("syncQueue").delete(e);else{const s=JSON.parse(localStorage.getItem("offline_syncQueue")||"[]").filter(i=>i.id!==e);localStorage.setItem("offline_syncQueue",JSON.stringify(s))}this.syncQueue=this.syncQueue.filter(t=>t.id!==e)}catch(t){console.error("Error removing queued action:",t)}}async cacheUserData(e){if(!e)return;const t={profile:{uid:e.uid,heroName:e.heroName,archetype:e.archetype,avatar:e.avatar,quitDate:e.quitDate,onboardingCompleted:e.onboardingCompleted},stats:e.stats||{},lastUpdated:Date.now()};await this.storeData("userData",t),this.offlineData.userData=t}async cacheProfileData(e){if(!e)return;const t={dailyWater:e.dailyWater||0,dailyMood:e.dailyMood||null,dailyBreathing:e.dailyBreathing||!1,scheduledTriggers:e.scheduledTriggers||[],relapseDate:e.relapseDate||null,cravingsResisted:e.cravingsResisted||0,lastUpdated:Date.now()};await this.storeData("profileData",t),this.offlineData.profileData=t}async getCachedUserData(){return this.offlineData.userData||(this.offlineData.userData=await this.getData("userData")),this.offlineData.userData}async getCachedProfileData(){return this.offlineData.profileData||(this.offlineData.profileData=await this.getData("profileData")),this.offlineData.profileData}async handleOfflineAction(e){return this.isOnline?await this.executeAction(e):await this.queueOfflineAction(e)}async handleOfflineBehavioralLog(e,t){try{const s=await this.enhancedManager.queueBehavioralLog(t.userId||"unknown",e,t,"normal");return console.log(`📝 Behavioral log queued: ${e} (${s})`),s}catch(s){console.error("❌ Error queuing behavioral log:",s);const i={type:"BEHAVIORAL_LOG",logType:e,logData:t,timestamp:Date.now(),userId:t.userId||"unknown"};if(this.isOnline)return await this.executeBehavioralLog(i);{const n=await this.queueOfflineAction(i);return this.showOfflineSaveNotification(e),n}}}async executeBehavioralLog(e){try{return"serviceWorker"in navigator&&navigator.serviceWorker.controller&&navigator.serviceWorker.controller.postMessage({type:"QUEUE_BEHAVIORAL_LOG",data:e}),console.log(`✅ Behavioral log executed: ${e.logType}`),!0}catch(t){return console.error("Error executing behavioral log:",t),await this.queueOfflineAction(e),!1}}async handleOfflineFirestoreAction(e,t){try{const s=await this.enhancedManager.queueFirestoreAction(t.userId||"unknown",e,t,"normal");return console.log(`📝 Firestore action queued: ${e} (${s})`),s}catch(s){console.error("❌ Error queuing Firestore action:",s);const i={type:"FIRESTORE_ACTION",actionType:e,actionData:t,timestamp:Date.now(),userId:t.userId||"unknown"};if(this.isOnline)return await this.executeFirestoreAction(i);{const n=await this.queueOfflineAction(i);return this.showOfflineSaveNotification(e),n}}}async executeFirestoreAction(e){try{return"serviceWorker"in navigator&&navigator.serviceWorker.controller&&navigator.serviceWorker.controller.postMessage({type:"QUEUE_FIRESTORE_ACTION",data:e}),console.log(`✅ Firestore action executed: ${e.actionType}`),!0}catch(t){return console.error("Error executing Firestore action:",t),await this.queueOfflineAction(e),!1}}async executeAction(e){try{const{ref:t,set:s,push:i}=await c(()=>import("./index.esm-980f89f8.js"),["assets/index.esm-980f89f8.js","assets/index-14a05817.js","assets/index-9c597206.css"]);switch(e.type){case"UPDATE_STATS":const n=t(window.db,`users/${e.userId}/stats`);await s(n,e.data);break;case"UPDATE_PROFILE":const r=t(window.db,`users/${e.userId}/profile`);await s(r,e.data);break;case"TRACK_HABIT":const a=t(window.db,`users/${e.userId}/profile/daily/${e.date}/${e.habitType}`);await s(a,e.value);break;case"RESIST_CRAVING":const o=t(window.db,`users/${e.userId}/profile/cravingsResisted`);await s(o,e.count);break;default:return console.warn("Unknown action type:",e.type),!1}return console.log(`✅ Action executed successfully: ${e.type}`),!0}catch(t){return console.error("Error executing action:",t),!1}}async handleReconnection(){console.log("🔄 Handling reconnection..."),this.hideOfflineIndicator(),setTimeout(async()=>{await this.syncOfflineActions(),await this.refreshOnlineData()},2e3)}async syncOfflineActions(){console.log("🔄 Syncing offline actions...");const e=await this.getQueuedActions();if(e.length===0){console.log("✅ No offline actions to sync");return}let t=0,s=0;for(const i of e)try{await this.executeAction(i.action)?(await this.removeQueuedAction(i.id),t++):(i.retryCount++,i.retryCount>=i.maxRetries&&(console.warn(`Action failed after ${i.maxRetries} retries:`,i),await this.removeQueuedAction(i.id),s++))}catch(n){console.error("Error syncing action:",n),i.retryCount++,i.retryCount>=i.maxRetries&&(await this.removeQueuedAction(i.id),s++)}console.log(`🔄 Sync complete: ${t} successful, ${s} failed`),t>0&&this.showSyncSuccessNotification(t),s>0&&this.showSyncFailureNotification(s)}async refreshOnlineData(){console.log("🔄 Refreshing online data...");try{window.refreshUserData&&await window.refreshUserData()}catch(e){console.error("Error refreshing online data:",e)}}showOfflineIndicator(){this.hideOfflineIndicator();const e=document.createElement("div");e.id="offline-indicator",e.className="fixed top-4 left-1/2 transform -translate-x-1/2 bg-yellow-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 flex items-center gap-2",e.innerHTML=`
      <span>📡</span>
      <span>You're offline - actions will sync when reconnected</span>
    `,document.body.appendChild(e)}hideOfflineIndicator(){const e=document.getElementById("offline-indicator");e&&e.remove()}showSyncSuccessNotification(e){const t=document.createElement("div");t.className="fixed top-20 right-4 bg-green-500 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm",t.innerHTML=`
      <div class="font-bold">✅ Sync Complete!</div>
      <div class="text-sm opacity-90">${e} offline action(s) synced successfully</div>
      <button class="mt-2 text-sm underline" onclick="this.parentElement.remove()">Dismiss</button>
    `,document.body.appendChild(t),setTimeout(()=>{t.parentNode&&t.parentNode.removeChild(t)},5e3)}showSyncFailureNotification(e){const t=document.createElement("div");t.className="fixed top-20 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm",t.innerHTML=`
      <div class="font-bold">⚠️ Sync Issues</div>
      <div class="text-sm opacity-90">${e} action(s) failed to sync. Check your connection.</div>
      <button class="mt-2 text-sm underline" onclick="this.parentElement.remove()">Dismiss</button>
    `,document.body.appendChild(t),setTimeout(()=>{t.parentNode&&t.parentNode.removeChild(t)},8e3)}showOfflineSaveNotification(e){const s={hydration:"💧 Water intake",craving:"🫁 Craving resistance",relapse:"⚠️ Relapse event",breathing:"🧘 Breathing exercise",walk:"🚶 Physical activity",meditation:"🧘‍♀️ Meditation",FIRESTORE_ACTION:"📊 Data sync",BEHAVIORAL_LOG:"📈 Analytics"}[e]||e,i=document.createElement("div");i.className="fixed top-20 right-4 bg-blue-500 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm",i.innerHTML=`
      <div class="font-bold">💾 Saved Offline</div>
      <div class="text-sm opacity-90">${s} will sync when you're back online</div>
      <button class="mt-2 text-sm underline" onclick="this.parentElement.remove()">Dismiss</button>
    `,document.body.appendChild(i),setTimeout(()=>{i.parentNode&&i.parentNode.removeChild(i)},4e3)}updateOfflineStatus(){this.isOnline||this.showOfflineIndicator()}async loadOfflineData(){try{this.offlineData.userData=await this.getData("userData"),this.offlineData.profileData=await this.getData("profileData"),this.syncQueue=await this.getQueuedActions(),console.log("📱 Offline data loaded:",{userData:!!this.offlineData.userData,profileData:!!this.offlineData.profileData,queuedActions:this.syncQueue.length})}catch(e){console.error("❌ Error loading offline data:",e),this.offlineData={userData:null,profileData:null},this.syncQueue=[]}}async checkForPendingSync(){this.isOnline&&this.syncQueue.length>0&&(console.log("🔄 Checking for pending sync..."),await this.syncOfflineActions())}getConnectionStatus(){return{isOnline:this.isOnline,queuedActions:this.syncQueue.length,lastSync:this.lastSyncTime}}async queueCreate(e,t,s,i="normal"){return await this.enhancedManager.queueCreate(e,t,s,i)}async queueUpdate(e,t,s,i,n="normal"){return await this.enhancedManager.queueUpdate(e,t,s,i,n)}async queueDelete(e,t,s,i="normal"){return await this.enhancedManager.queueDelete(e,t,s,i)}async getQueueDetails(){return await this.enhancedManager.getQueueDetails()}async retryFailedOperations(){return await this.enhancedManager.retryFailedOperations()}async clearAllQueues(){return await this.enhancedManager.clearAllQueues()}getEnhancedStatus(){return this.enhancedManager.getStatus()}getEnhancedManager(){return this.enhancedManager}async clearOfflineData(){try{if(await this.enhancedManager.clearAllQueues(),this.storageType==="indexedDB"&&this.db){const e=this.db.transaction(["userData","offlineActions","syncQueue"],"readwrite");await Promise.all([e.objectStore("userData").clear(),e.objectStore("offlineActions").clear(),e.objectStore("syncQueue").clear()])}else Object.keys(localStorage).forEach(e=>{e.startsWith("offline_")&&localStorage.removeItem(e)});this.offlineData={},this.syncQueue=[],console.log("🧹 Offline data cleared")}catch(e){console.error("Error clearing offline data:",e)}}destroy(){this.enhancedManager&&this.enhancedManager.destroy()}}export{y as default};
